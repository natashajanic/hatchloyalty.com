# Hatchloyalty.com

> A Gatsby.js application that generates the [Hatch Loyalty marketing website](https://www.hatchloyalty.com/).

## Intro

This application uses [Gatsby.js](https://www.gatsbyjs.org/) to generate the static website for the [Hatch Loyalty marketing website](https://www.hatchloyalty.com/). Gatsby builds on React to generate the site but allows the site's content to be loaded from a variety of data sources (e.g. markdown, json, etc). This is a dramatic simplification of Gatsby, so for a more detailed understanding please review [their documentation](https://www.gatsbyjs.org/docs/).

The site can be built and run locally for rapid development. It is automatically deployed to [Netlify](https://www.netlify.com/) as part of the CI setup for this application to allow for public sharing and review of proposed changes to the site. In production it is deployed to __TODO: document production deployment__.

## Development

* `nvm use`: Loads the proper Node version to be used for this application. Requires [NVM](https://github.com/creationix/nvm) to be installed.
* `yarn install`: Installs/updates all package dependencies.
* `yarn tsc`: Runs the typescript compiler on all source files reporting any errors found.
* `yarn lint`: Runs the typescript lint checker on all source files reporting any errors or warnings found.
* `yarn format`: Executes prettier, updating the files throughout the application according to the configuration for this app.
* `yarn test`: Executes the full automated test suite.
* `yarn develop`: Launches the application on your local machine, hosting it on port 8000.

## Deployment

### CI Integration

[Netlify](https://www.netlify.com/) has been integrated into our CI setup for this application. As a result, each PR will be deployed to a Netlify site. The results of this deployment can be accessed directly in the Netlify web console or via a link in the CI section of each pull request.

### Manual

__TODO:__ Document the staging and production deployment processes.

## General Notes

* GraphQL:
  * Gatsby uses GraphQL to allow site information and content to be loaded during the build process.
  * For developers more accustomed to a standard React application, this can take some getting used to but in some ways it serves as a replacement for Redux in this context and can be helpful to loosely think about in that manner.
  * If you're not familiar with GraphQL, I'd highly recommend taking a few minutes to familiarize yourself with it and play around in the [GraphQL IDE](http://localhost:8000/___graphql) (a.k.a GraphiQL).
* Typescript:
  * We've migrated as much of the application as possible to Typescript and have a set of linter checks configured to enforce consistency across the application.
  * All files under `src/` should use Typescript and all compiler and linter errors should be addressed before pushing your changes to Github.
  * Both the compiler and linter are run as part of the CI checks for this application.
* Test Coverage:
  * Jest has been integrated as the test framework across the application and is run as part of the CI checks.
  * There are a few caveats to using Jest within a Gatsby app.
  * In particular GraphQL queries are incompatible with the test framework since they are not a syntactically valid JS format and must be pre-processed by Gatsby. As a result, we follow a pattern of [isolating the these queries](https://www.gatsbyjs.org/docs/testing-components-with-graphql/#testing-staticquery) where possible to allow components to be testable.
  * This approach does not work for queries that contain variables, since the `StaticQuery` component only supports _static queries_. As a result components that require variables in their queries must be left untested at this time.
* App Structure:
  ```
    .
    ├── .cache (generated by build)
    ├── .circleci
    ├── config
    ├── content
    ├── node_modules (generated by installing package dependencies)
    ├── public (generated by build)
    ├── src
    ├── static
    ├── tests
    ├── typings
    ├── .gitignore
    ├── .nvmrc
    ├── .prettierrc
    ├── gatsby-browser.js
    ├── gatsby-config.js
    ├── gatsby-node.js
    ├── jest.json
    ├── LICENSE
    ├── package.json
    ├── README.md
    ├── tsconfig.json
    ├── tslint.json
    └── yarn.lock
  ```
  * **`/.cache`**: Cache data generated when the site is built. If you find you're not seeing changes take affect in your local environment, it can be helpful to delete this directory entirely and run a fresh rebuild. Do NOT check this directory into git.
  * **`/.circleci`**: Configuration of the CI process for this application, including the compilation, linting, and testing of the app.
  * **`/config`**: A set of JS files that define the Gatsby configuration of the application. These files allow us to organize the logic that would otherwise live in the `gatsby-*.js` files.
  * **`/content`**: All of the markdown and JSON content that will be used to generate the various pages within the site.
  * **`/node_modules`**: All of the modules of code that your project depends on (npm packages) are automatically installed. Do NOT check this directory into git.
  * **`/public`**: The built version of the application (i.e. the Gatsby output). Do NOT check this directory into git.
  * **`/src`**: All code related to what you see on the front-end of the site including the definitions for each page's structure and the components that are used in each page.
  * **`/static`**: A set of static files that will be included with the final version of the site. The structure of the directories within this folder dictate the location/URL for the files once the site is built.
  * **`/‘tests`**: A set of configuration files used to setup the Jest framework properly for this app. The actual tests themselves are found in the `__tests__` directories within `src/`.
  * **`/typings`**: Type definitions required to support compiling the application.
  * **`.gitignore`**: Configuration for the files that git will ignore.
  * **`.prettierrc`**: Configuration for [Prettier](https://prettier.io/).
  * **`gatsby-browser.js`**: Any customizations/extensions of default Gatsby settings affecting the browser. See the [Gatsby browser APIs](https://www.gatsbyjs.org/docs/browser-apis/) for more information.
  * **`gatsby-config.js`**: Main configuration file for a Gatsby site. Defines common information about the site (metadata) like the site title and description, specifies the Gatsby plugins to be included, etc. Check out the [config docs](https://www.gatsbyjs.org/docs/gatsby-config/) for more information.
  * **`gatsby-node.js`**: Configuration of the Gatsby build process, including the set of pages to be generated for the site. See the [Gatsby Node APIs](https://www.gatsbyjs.org/docs/node-apis/) for more information.
  * **`jest.json`**: Configuration of the [Jest test framework](https://jestjs.io/docs/en/configuration.html).
  * **`LICENSE`**: Gatsby's license.
  * **`package.json`**: A manifest file for Node.js projects, which includes things like metadata (the project’s name, author, etc).
  * **`README.md`**: This file, providing helpful information about how to setup and develop within this application.
  * **`tsconfig.json`**: Configuration of the [Typescript compiler](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html).
  * **`tslint.json`**: Configuration of the [Typescript linter](https://palantir.github.io/tslint/usage/configuration/).
  * **`yarn.lock`**: Specification for all Node packages used within the app, ensuring all developers and environments use a consistent set of package versions.

## TODOs

* Decompose pages and templates into testable components, leaving only the page structure/organization to be dictated by these classes. These classes are not testable since the GraphQL queries in some cases (e.g. when variables are used) must be defined as a page query, rather than being able to use StaticQuery. As a result, these classes cannot be loaded by Jest, our test framework, which does not recognize and cannot parse these GraphQL queries which are intended to be pre-processed by Gatsby.
* Find a better way to manage paths and routing throughout the app. Right now this uses a lot of hard-coded strings.
* Standardize data models used throughout the app (e.g. Blog, Resource, Team Member, etc). Define clear interfaces for these data models and use them consistently. Right now, a number of single-use structures are used for these data models making it unclear when it's safe to access various properties of these models.
